# 인덱스 컨디션 푸시다운

```mysql
> SELECT * FROM employees WHERE last_name='Acton' AND first_name LIKE '%sal';
```

위 쿼리에서 last_name을 통해 인덱스 레인지 스캔을 할 수 있다. 하지만 first_name 의 like 검색은 인덱스 레인지 스캔으로 좁힐수 없다. 그래서 다음 쿼리에서는 last_name 조건은 ix_latname_firstname 인덱스의 특정 범위만 조회할 수 있는 조건이며, first_name LIKE '$sal' 조건은 데이터를 모두 읽은 후 사용자가 원하는 결과인지 하나씩 비교해보는 조건으로만 사용된다. 

따라서 실행 계획은 다음과 같다.

```mysql
----------------------------------------------------------------------------------------------------
| id | select_type | table         | type | key                   | key_len | Extra                |
----------------------------------------------------------------------------------------------------
| 1  | SIMPLE     | employees      | ref  | ix_lastname_firstname  | 66     | Using Where          |     
----------------------------------------------------------------------------------------------------
```

여기서 Using Where는 스토리지 엔진이 읽어서 반환해준 레코드가 인덱스를 사용할 수 없는 WHERE 조건에 일치하는지 검사하는 과정을 의미한다. 즉 first_name LIKE '$sal'이 검사 과정에 사용된 조건이다.

5.5 버전 이전까지는 ix_lastname_firstname 인덱스에서 일치하는 레코드를 가지고와 employees에 like 검색을 하면 된다. 이 때 만약 ix_lastname_firstname인덱스에서 10만건의 데이터가 일치하고 그중에 단 1건만 LIKE 검색에 일치했다면 99999건은 불필요하게 읽은 셈이다. 

이는 first_name 조건을 비교하는 작업을 MySQL 엔진이 수행했기 때문에 스토리지 엔진이 전체 데이터를 가지고 와 비교할 수 밖에 없었다.

하지만 5.6부터는 인덱스 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 컬럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선되었다. 그래서 MySQL 엔진이 조건을 처리하고 최대한 필터링해 스토리지 엔진에게 넘겨준다. 즉 99999건의 데이터를 불 필요하게 읽지 않게 되었다. 

인덱스 컨디션 푸시 다운을 설정하면 다음과 같은 실혱계획이 세워진다.

```mysql
-----------------------------------------------------------------------------------------------------
| id | select_type | table         | type | key                   | key_len | Extra                 |
-----------------------------------------------------------------------------------------------------
| 1  | SIMPLE     | employees      | ref  | ix_lastname_firstname  | 66     | Using index condition |     
-----------------------------------------------------------------------------------------------------
```