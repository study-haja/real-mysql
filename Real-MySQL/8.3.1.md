# 8.3.1 B-Tree 구조 및 특성

B-Tree의 구조는 다음과 같다. 

1. 루트 노드
2. 브랜치 노드
3. 리프 노드

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다. 다음 그림을 보자.

<img src="https://user-images.githubusercontent.com/45676906/121980925-c60f2780-cdc7-11eb-8bff-9a17dadb2886.png" alt="MySQL B-Tree 인덱스란?" style="zoom:50%;" />

위그림에서 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.

 많은 사람들이 데이터 파일의 레코드는 INSERT 된 순서대로 저장되는 것으로 생각하지만 그렇지 않다. 레코드가 삭제되면 그 공간을 재활용 하기 때문에 순서대로 저장되지 않는다.

> InnoDB 테이블은 클러스터가 되어 데이터를 저장하기 때문에 프라이머리키 순서대로 정렬되어 저장한다. 참고로 다른 데이터베이스는 클러스터링 기능이 선택사항이지만 InnoDB는 디폴트 기능이다.

인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 따라서 리프 노드의 레코드 주소를 통해 데이터 파일에 접근해 나머지 컬럼들을 읽어오게 만든다.

MyISAM 인덱스와 InnoDB 인덱스 레코드 주소는 다음과 같은 차이가 있다.

1. MyISAM의 레코드 주소 : 테이블의 insert 순번이거나 데이터 파일 내의 위치
2. InnoDB의 레코드 주소 : 데이터 파일 내의 노드를 형성해 데이터를 찾음

이 둘의 큰 차이점은 MyISAM은 물리적 주소를 가지고 있고 InnoDB는 논리적 주소를 가진다는 것이다. 따라서 InnoDB는 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다. 즉 인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다. 이는 단점으로 보일 수 있지만 둘다 각각 장단점이 있다.