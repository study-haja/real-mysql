# 인덱스란?

인덱스를 책에 비유하면 다음과 같다.

1. 인덱스 : 부록 (찾아보기)
2. 데이터 파일 : 책의 내용
3. 레코드 주소 : 페이지 번호

즉 key(인덱스 키) - value(레코드 주소) 구조와 정렬된 상태로 레코드를 저장시켜 데이터를 빠르게 탐색할 수 있게 만든다.

인덱스와 자료구조를 비교해보면 다음과 같다.

1. SortedList - 저장된 값을 항상 정렬된 상태로 유지하는 구조
   1. 장점 : 데이터가 저장될 때마다 정렬을 해주기 때문에 복잡하고 느림
   2. 단점 : 데이터를 탐색시킬때 빠르게 찾아줌
2. ArrayList - 저장된 순서 그대로 유지하는 구조

즉 SortedList는 인덱스와 같으며 CUD의 성능을 버리고 R의 속도를 높힌다. 또한 인덱스를 하나씩 더 추가하면 할 수록 저장 성능이 느려진다. 그렇기 때문에 아무리 Where 조건절에 자주 사용한다 하더라도 인덱스를 걸면 역효과를 볼 수 있다.

인덱스는 다음과 같은 역할로 나뉘어 진다.

* 프라이머리 키 (프라이머리 인덱스)
  * 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미
  * 이 컬럼은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 우리는 이를 식별자라고도 부름
  * Null값, 중복 허용 x
* 세컨더리 키 (세컨더리 인덱스)
  * 프라이머리 키를 제외한 모든 컬럼에 거는 인덱스를 세컨더리 인덱스라 부름
  * 유니크 인덱스는 프라이머리 키와 성격이 비슷하여 대체해서 사용 가능

인덱스의 데이터 저장 알고리즘은 다음과 같다.

* B-Tree 인덱스
  * 가장 일반적인 알고리즘
  * 해당 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
* Hash 인덱스
  * 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원
  * 하지만 값을 변형해서 인덱싱하므로 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없음
  * 주로 메모리 기반의 데이터베이스에서 많이 사용

또한 유니크 인덱스에 대해 동등 조건으로 검색하면 항상 1건의 코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에게 알려주기 때문에 유니크하냐 안하냐에 따라 옵티마이저에게 상당히 중요한 문제가 된다.

