### 9.2.3 ORDER BY 처리(Using file sort)

- 정렬을 처리하는 방법 두가지와 장단점
||장점|단점|
|------|---|---|
|인덱스 이용|인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.|- INSERT,UPDATE,DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.<br />- 인덱스 때문에 디스크 공간이 많이 필요<br />- 인덱스 갯수가 늘어날수록, InnoDB 버퍼 풀을 위한 메모리가 많이 필요|
|Filesort 이용|- 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀜<br />- 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름|정렬작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느림|

- 인덱스를 사용하지 못하고 Filesort를 이용할수 밖에 없는경우
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
  - 랜덤하게 결과 레코드를 가져와야 하는 경우



#### 9.2.3.1 소트 버퍼

> MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트버퍼(Sort buffer)라고 함.





- 정렬해야할 레코드가 많은 경우에, sort buffer 공간에 한번에 적재할수 없기때문에, 아래 그림처럼 레코드를 여러조각으로 나누어 정렬한후 TEMP FILE로 저장해야 한다. 그리고 이어서 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 한다.

  ![img](https://mblogthumb-phinf.pstatic.net/MjAxOTA5MjBfMTA4/MDAxNTY4OTI4ODc1ODYy.2XzPWHfti_pOn-5odjFKdtnwwC2VJM3qUtgEmagpryYg.t5kNgX9TGp8yJpAq960Ksp7nEl8EJWsdtoniVLICaSog.PNG.jevida/091919_2134_MySQLMariaD2.png?type=w800)

- `sort_buffer_size`가 크면 메모리에서 더 많이 처리될수 있으니 정렬 속도가 빨라질것으로 예상하지만 실제로는 그렇지 않다. 오히려 리눅스 계열의 운영체제에서는 너무 큰 sort_buffer_size를 사용하는 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있다.

  - 예를들어, 소트 버퍼의 크기를 10MB이상으로 설정한뒤 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면 운영체제는 메모리 부족 현상을 겪을 수도 있다. 운영체제는 이때 여유 메모리를 확보하기 위해 프로세스를 강제로 종료하게 되는데, MySQL이 보통 메모리를 가장 많이 사용하므로 강제 종료대상이 된다.