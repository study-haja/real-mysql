# 인덱스의 정렬

인덱스를 생성하는 시점에서 컬럼을 오름차순 혹은 내림차순으로 설정 할 수 있다. 

5.7 버전까지는 ASC, DESC를 혼합해서 인덱스를 생성할 수 없었지만, 8.0부터는 혼합해서 인덱스를 생성할 수 있게 만들었다.

```mysql
> CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```



## 인덱스 스캔 방향

다음 오름차순으로 정렬된 인덱스를 가진 테이블에서 데이터를 가지고 오는 예이다

```mysql
> SELECT *
	FROM employees
	ORDER BY first_name DESC
	LIMIT 1;
```

위 예제를 보면 오름차순의 맨 마지막 값이니 오름차순을 끝까지 읽는다고 생각할 수 있지만, 사실 옵티마이저는 알아서 실행계획을 세워 최적의 조건으로 탐색한다. 

위 예에서 옵티마이저는 인덱스를 역순으로 접근해 첫번째 레코드만 읽으면 된다고 알고 있다.

즉 오름차순으로 생성된 인덱스를 정순으로 읽으면 자동으로 오름차순으로 정렬된 결과가 되고, 역순은 내림차순으로 정렬된 결과값을 얻을 것이다.

```mysql
// first_name 인덱스
> SELECT * FROM employees WHERE first_name >= 'Anneke'
	ORDER BY first_name ASC LIMIT 4;
	
> SELECT * FROM employees
	ORDER BY first_name DESC LIMIT 5;
```

첫번째 쿼리는 먼저 Anneke라는 레코드를 찾은 후, 정순으로 해당 인덱스를 읽으면서 4개의 레코드만 가지고 온다. 두번째는 first_name 역순으로 읽으면서 처음 다섯개의 레코드만 가져고 온게 한다.



## 내림차순 인덱스

2개 이상의 컬럼으로 구성된 복합 인덱스에서 각각의 컬럼이 내림차순과 오름차순이 혼합된 경우, 8.0의 내림차순 인덱스로만 해결할 수 있다.

```mysql
> CREATE INDEX ix_firstname_asc ON employees (first_name ASC);

>CREATE INDEX ix_firstname_asc ON employees (first_name DESC);
```

위 first_name 기준 2개의 오름차순, 내림차순 인덱스가 있는데 어떤것이 빠를까? 아니면 같을까? 우선 용어정리부터 하자.

* 오름차순 인덱스 : 작은 값의 인덱스의 키가 B-Tree의 왼쪽으로 정렬된 인덱스
* 내림차순 인덱스 : 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
* 인덱스 정순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
* 인덱스 역순 스캔 : 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

InnoDB 기준 하나의 테이블에 1천 2백여만건 데이터를 인덱스 정순과 역순으로 풀 스캔했을시 정순이 역순에 비해 28퍼 정도 빨랐다고 한다. 

물론 InnoDB에서 정순과 역순 스캔의 양방향 연결 고리를 통해 전진하느냐 후진하느냐의 차이만 있다고 생각할 수 있지만, 실제 내부적으로 InnoDB가 정순이 더 빠를수 밖에 없는 2가지 이유가 있다.

1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

```
| infimun | -> 
| 키 1, 데이터 : xxx | -> | 키 2, 데이터 : xxx | -> | 키 3, 데이터 : xxx | -> 
| 키 4, 데이터 : xxx | -> | 키 5, 데이터 : xxx | -> | 키 6, 데이터 : xxx | -> 
| Supremum |
```

위 예제와 같이 InnoDB 페이지 내에서 레코드들이 연결되어 있다. 또한 InnoDB 페이지는 힙처럼 사용되기 때문에 물리적으로 저장이 순서대로 배치되지 않는다.

따라서 정리하자면 서비스에서 일반적으로 인덱스를 ORDER BY ... DESC하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 사용할 필요가 없다. 

하지만 많은 레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적이라고 볼 수 있다.

또한 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병복이 될것으로 예상된다면, 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 될 것이다.