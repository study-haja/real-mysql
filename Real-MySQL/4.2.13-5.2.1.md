### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 8.0에서는 모든기능이 InnoDB 스토리지 엔진기반으로 재편되었고, MyISAM 스토리지 엔진만이 가지는 장점은 없어진 상태이다.

- 싱글 스레드에서만 데이터를 읽고 쓴다면, MEMORY 스토리지 엔진은 InnoDB에 비해서 더 빠를 수 있다. 하지만 멀티 스레드에서 데이터를 읽고 쓸때는 테이블 수준의 잠금으로 인해서 성능을 제대로 내지 못한다.

## 4.3 MyISAM 스토리지 엔진 아키텍쳐

![MyISAM 스토리지 엔진 아키텍처](https://t1.daumcdn.net/cfile/tistory/27706D4D573DB42713)

### 4.3.1 키 캐시

InnoDB의 버퍼 풀과 비슷한 역할을하는 것이 MyISAM의 키 캐시(Key cache, 키 버퍼라고도 불림)다. 인덱스만을 대상으로 작동하며, 또한 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을한다.

### 4.3.2 운영체제의 캐시 및 버퍼

MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색가능하다. 하지만 테이블의 데이터에 대해서는 디스크 IO를 해결해 줄 마한 캐시나 버퍼링 기능을 가지고 있지 않다. 따라서 MyISAM 테이블의 데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청될 수 밖에 없다.

다른 어플리케이션의 메모리 사용량에 따라서 캐시 용도로 사용가능한 메모리 공간이 달라진다. 따라서 데이터베이스에서 MyISAM 테이블을 주로 사용한다면 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리를 비워두어야 한다.

MyISAM이 주로 사용하는 MySQL에서 일반적으로 키 캐시는 최대 물리 메모리의 **40%** 이상을 넘지 않게 설정하고, 나머지 메모리 공간은 운영체제가 자체적인 파일 시스템을 위한 캐시 공간을 마련할 수 있게 해주는 것이 좋다.

### 4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조

MyISAM 테이블에 레코드는 프라이머리 키 값과 무관하게 `INSERT`되는 순서대로 데이터 파일에 저장된다. 그리고 MyISAM 테이블에 저장되는 레코드는 모두 ROWID라는 물리적인 주솟값을 가지는데, 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 ROWID 값을 포인터로 가진다.

## 4.4 MySQL 로그 파일

MySQL 서버에 대한 깊은 내부 지식이 없어도, 로그 파일을 잘 살펴보면 MySQL의 상태나 부하를 일으키는 원인을 쉽게 찾아서 해결할 수 있다.

### 4.4.1 에러 로그 파일

MySQL 설정파일(my.cnf)에서 `log_error` 라는 이름의 파라미터로 정의된 경로에 생성된다.

#### 4.4.1.1 MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지

MySQL의 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 이후 다시 시작하는 경우에는 반드시 MySQL 에러 로그 파일을 통해 설정된 변수의 이름이나 값이 명확하게 설정되고 의도한 대로 적용됐는지 확인해야 한다.

#### 4.4.1.2 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트래젝션 복구 메시지

InnoDB의 경우에는 MySQL 서버가 비정상적 또는 강제적으로 종료됐다면 다시 시작되면서 완료되지 못한 트랜젝션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 하게 된다. 이 과정에서 문제가 생기면 `innodb_force_recovery` 파라미터를 0보다 큰 값으로 설정하고 재시작해야 한다.

#### 4.4.1.3 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지

쿼리 도중 발생하는 문제점은 사전예방이 어려우며, 주기적으로 에러 로그 파일을 검토하는 과정에서 알게된다.

#### 4.4.1.4 비정상적으로 종료된 커넥션 메시지(Aborted connection)

클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 MySQL 서버의 에러 로그 파일에 이런 내용이 기록된다. 물론 중간에 네트워크 문제가 있어서 의도하지 않게 접속이 끊어지는 경우에도 이런 메시지가 기록된다. 이런 메시지가 아주 많이 기록된다면 애플리케이션의 커넥션 종료 로직을 한번도 검토할 필요가 있다.

#### 4.4.1.5 InnoDB의 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS와 같은)의 결과 메시지

상대적으로 큰 메시지를 로그 파일에 기록하므로, 시스템의 공간을 다 사용해버릴수 있다. 모니터링을 사용한 이후에는 다시 비활성화해서 에러 로그 파일이 커지지 않게 만들어야 한다.

#### 4.4.1.6 MySQL의 종료 메시지

MySQL이 아무도 모르게 종료돼 있거나 때로는 아무도 모르게 재시작하는 경우를 본적이 있을것이다. 이런 경우는 MySQL이 마지막으로 종료되면서 출력한 메시지를 확인하는 것이 원인을 찾는 유일한 방법이다.

### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)

가끔 MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아서 검토해 볼 때가 있는데, 이때는 쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일로 기록하게 한 다음, 그 파일을 검토한다.

### 4.4.3 슬로우 쿼리 로그

슬로우 쿼리 로그 파일에는 `long_query_time` 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다. 슬로우 쿼리 로그는 MySQL이 쿼리를 실행한 후, 실제 소요된 시간을 기준으로 슬로우 쿼리 로그에 기록할지 여부를 판단하기 때문에 반드시 쿼리가 정상적으로 실행이 완료돼야 슬로우 쿼리 로그에 기록될 수 있다.

일반적으로 슬로우 쿼리 또는 제너럴 로그 파일의 내용이 상당히 많아서 직접 쿼리를 하나씩 검토하기에는 시간이 너무 많이 걸리거나 어느 쿼리를 집중적으로 튜닝해야 할지 식별하기가 어려울 수 있다. 이런 경우에는 Percona에서 개발한 `Percona Toolkit`의 `pt-query-digest` 스크립트를 이용하면 쉽게 빈도나 처리 성능별로 쿼리를 정렬해서 살펴볼 수 있다.

로그 파일의 분석이 완료되면 그 결과는 다음과 같이 3개의 그룹으로 나뉘어 저장된다.

- 슬로우 쿼리 통계
- 실행 빈도 및 누적 실행 시간순 랭킹
- 쿼리별 실행 횟수 및 누적 실행 시간 상세정보

# 5. 트랜잭션과 잠금

트랜잭션은 작업의 완전성을 보장해 준다. 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.

잠금은 동시성을 제어하기 위한 기능이고 트랜젝션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

## 5.1 트랜젝션

많은 사람들이 MySQL 서버에서는 MyISAM이나 Memory 스토리지 엔진이 더 빠르다고 생각하고 InnoDB 스토리지 엔진은 사용하기 복잡하고 번거롭다고 생각하곤 한다. 하지만 사실은 MyISAM이나 MEMORY 같이 트랜젝션을 지원하지 않는 스토리지 엔진의 테이블이 더 많은 고민거리를 만들어 낸다.

### 5.1.1 MySQL에서의 트랜잭션

트랜잭션 관점에서 InnoDB 테이블과 MyISAM 테이블의 차이를 살펴보자.

``` mysql
mysql> CREATE TABLE tab_myisam ( fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
mysql> INSERT INTO tab_myisam (fdpk) VALUES (3);

mysql> CREATE TABLE tab_myisam ( fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=INNODB;
mysql> INSERT INTO tab_myisam (fdpk) VALUES (3);
```

위와 같이 테스트용 테이블에 각각 레코드를 1건씩 저장한 후 AUTO-COMMIT 모드에서 다음 쿼리들을 실행해보자.

```mysql
mysql> SET autocommit=ON;
mysql> INSERT INTO tab_myisam (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'
mysql> INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'
```

각각의 테이블을 조회해보면 결과는 아래와 같다.

``` mysql
mysql> SELECT * FROM tab_myisam;
fdpk
1
2
3
mysql> SELECT * FROM tab_innodb;
fdpk
3
```

위에서 보듯이 innoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 것을 확인할 수 있다. MyISAM 테이블의  경우 부분 업데이트 현상이 발생했는데, 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요하다. 비즈니스 로직에 데이터 삭제 로직도 넣으면 코드가 정말 지저분해진다.

### 5.1.2 주의 사항

프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜젝션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다. 또한 프로그램의 코드에서 라인수는 한두 줄이라고 하더라도 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다. 이런 실수로 인해 DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 빈번히 발생한다.

## 5.2 MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 **스토리지 엔진 레벨** 과 **MySQL 엔진레벨** 로 나눌수 있다. MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다.

### 5.2.1 글로벌 락

글로벌 락(GLOBAL LOCK)은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금가운데 가장 범위가 넓다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다. 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터 베이스가 다르더라도 동일하게 영향을 미친다. MyISAM이나 MEMORY 테이블에 대한 `mysqldump` 로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다.

> `FLUSH TABLES WITH READ LOCK` 명령은 테이블에 읽기 잠금을 걸기 전에 먼저 테이블을 플러시해야 하기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료돼야 한다. 그래서 장기간 SELECT 쿼리가 실행되고 있을 때는 `FLUSH TABLES WITH READ LOCK` 명령은 `SELECT`쿼리가 종료될 때까지 기다려야 한다.
>
> 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋다.

InnoDB 스토리지 엔진은 트랜젝션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없다. 또한 MySQL 8.0 버전부터는 `Xtrabackup` 이나 `Enterprise Backup`과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다. 

특정 세션에서 백업락을 획득하면 모든 세션에서 다음 작업을 수행할 수 없게 된다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경,삭제
- `REPAIR TABLE` 과 `OPTIMIZE TABLE`명령
- 사용자 관리 및 비밀번호 변경

백업락은 일반적인 테이블의 데이터 변경은 허용된다. 백업도중 DDL 명령 하나로 인해 백업이 실패하면 다시 그만큼 시간을 들여서 백업을 다시해야한다. 이러한 문제를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지한다.
