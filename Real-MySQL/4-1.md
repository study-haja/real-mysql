# 아키텍처

MySQL 서버는 다음과 같은 역할로 나뉘어져 있다.

1. **MySQL 엔진** : 사람의 머리역할을 담당
2. **스토리지 엔진** : 손발 역할을 담당
   * 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용 가능



## MySQL 엔진 아키텍처

먼저 MySQL의 쿼리를 작성하고 튜닝할 때 필요한 기본적인 MySQL 엔진의 구조를 보자.



### MySQL의 전체 구조

![Real MySQL 정리](https://user-images.githubusercontent.com/43127088/108531720-5bb71080-731a-11eb-8b51-288f49a4a600.PNG)

[ source : https://junghyungil.tistory.com/135 ]

위 그림과 같이  MySQL은 일반 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원한다. C API, JDBC, ODBC, .NET의 표준       드라이버를 제공하며, 이러한 드라이버를 이용해 C, C++, PHP, JAVA, .NET 등 다양한 언어로 MySQL 서버에서 쿼리를 사용할 수 있게 지원한다.



#### MySQL 엔진

MySQL엔진은 다음과 같이 중심을 이룬다.

1. 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
2. SQL 파서
3. 전처리기
4. 쿼리의 최적화된 실행을 위한 옵티마이저

즉 요청된 SQL 문장을 분석하거나 최적화하는등 DBMS의 두뇌에 해당하는 역할을 한다. 그리고 MySQL은 표준 SQL 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.



#### 스토리지 엔진

스토리지 엔진은 다음과 같은 기능을 가지고 있다.

1. 실제 데이터를 디스크 스토리지에 저장하거나, 디스크 스토리지로부터 데이터를 읽어오는 부분을 담당
2. MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러개 사용 가능
3. 성능 향상을위해 키 캐시(MyISAM 스토리지 엔진) 혹은 InnoDB 버퍼 풀(InnoDB 스토리지 엔진) 과 같은 기능을 내장

스토리지 엔진을 적용시키면 다음과 같다.

* InnoDB 엔진을 적용시킨 CREATE 테이블 문구

```mysql
/* test_table에 CRUD 작업이 발생하면 앞으로 InnoDB를 사용해서 처리 */
> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```



#### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 읽고 쓸 때, 각 스토리지 엔진에 쓰기 읽기 요청을 하는데 이 때를 핸들러 요청이라 하고 여기에 사용되는 API를 핸들러 API라고 한다.

InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다. 

이 핸들러 API를 통해 얼마나 많은 데이터 작업이 있었는지 확인하려면 다음과 같은 명령어를 치면 된다.

* 얼마나 많은 데이터 작업이 있었는지 확인할 수 있는 명령어

```mysql
> SHOW GLOBAL STATUS LIKE 'Handler%';

| Variable_name | Value |
-------------------------
|Handler_commit | 2696  |
|Handler_delete | 184   |
...
```



### MySQL 쓰레딩 구조

MySQL 서버는 프로세스 기반이 아닌 쓰레드 기반으로 작동되며 구조는 다음과 같다.

![MySQL](https://media.vlpt.us/images/fortice/post/f7da9248-5080-45a6-b018-37866b6492e3/image.png)

[ source : https://junghyungil.tistory.com/135 ]

크게 포그라운드 쓰레드와 백그라운드 쓰레드로 구본할 수 있으며 실행 중인 쓰레드 목록은 다음과 같다.

* 실행중인 쓰레드 목록을 확인 하는 예제

```mysql
> SELECT thread_id, name, type, processlist_user, processlist_host
  FROM performance_schema.threads ORDER BY type, thread_id;
```

위 예제에서 많은 쓰레드 값들이 나오게 되는데 중요한 부분만 정리하면 다음과 같다.

1. `thread/sql/comnnection` 쓰레드는 **실제 사용자의 요청을 처리**하는 포그라운드 쓰레드
2. 백그라운드 쓰레드는 MySQL 설정에 따라 개수가 달라짐
3. 동일한 이름의 쓰레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 쓰레드가 동일 작업을 병렬로 처리하는 경우



#### 포그라운드 쓰레드 ( 클라이언트 쓰레드 )

포그라운드 쓰레드는 다음과 같은 성질을 가지고 있다.

1. 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재
2. 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
3. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 쓰레드는 다시 쓰레드 캐시로 리턴
   * 이미 스레드 캐시에 일정 개수 이상의 대기 중인 쓰레드가 있으면 쓰레드 캐시에 넣지 않고 쓰레드를 종료시켜 일정개수의 쓰레드만 쓰레드 캐시에 존재하게 함
   * 쓰레드 캐시에 유지할 수 있는 최대 쓰레드 개수는 thread_cache_size 시스템 변수로 설정
4. 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로 부터 데이터를 읽어와서 작업을 처리
   * MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 쓰레드가 처리
   * InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 쓰레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 쓰레드가 처리



#### 백그라운드 쓰레드

InnoDB 기준 백그라운드 쓰레드에서 많은 작업을 처리한다. 작업은 다음과 같다.

* Insert Buffer를 병합하는 쓰레드
* 로그를 디스크로 기록하는 쓰레드 (Log Thread)
* InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 쓰레드 (Write Thread)
  * 버퍼에 있는 데이터를 디스크로 내려 쓰기 작업 진행
  * MySQL 5.5 부터 데이터 쓰기 쓰레드와 데이터 읽기 쓰레드 개수를 2개 이상 지정할 수 있게 됐으며, innodb_write_threads, innodb_read_io_threads 시스템 변수로 설정 가능
  * 주로 읽는 작업은 클라이언트 쓰레드에서 처리하기 때문에 많은 설정이 필요 x
  * 쓰기 작업은 아주 많은 일을 하기 때문에 백그라운드로 처리
  * 주로 내장 디스크 기준 2~4로 설정
* 데이터를 버퍼로 읽어 오는 쓰레드
* 잠금이나 데드락을 모니터링하는 쓰레드

사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연되어 처리될 수 잇지만데이터의 읽기 작업은 절대 지연될 수 없다.그래서 일반적인 상용 DBMS에는 대부분 쓰기 작업을 **버퍼링**해서 일괄 처리하는 기능이 탑재 되어 있으며, InnoDB 또한 이런 방식으로 처리한다.

하지만 MyISAM은 사용자 쓰레드가 쓰기 작업까지 함께 처리하도록 설계 되어 있다. 그 이유는 CUD 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장 될 때까지 기다리지 않아도 되기 때문이다. 그렇다고 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.



### 메모리 할당 및 사용 구조

MySQL의 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분된다. 글로벌 메모리 영역의 모든 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다. 운영체제마다 다르겠지만 100%할당될 수 있고, 미리 메모리를 예약하고 조금씩 제공해주는 방법을 사용할 수 있다.

운영체제의 메모리 할당 방식은 매우 복잡하기 때문에, 단순히 MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당 받는다고 생각하면 된다.



#### 글로벌 메모리 영역

일반적으로 클라이언트 쓰레드의 수와 무관하게 하나의 메모리공간만 할당된다. 

단, 필요에 따라 2개 이상의 메모리 공간을 할당 받을 수도 있지만 클라이언트의 쓰레드 수와는 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 쓰레드에 의해 공유된다.

대표적인 글로벌 메모리 영역은 다음과 같다.

1. 테이블 캐시
2. InnoDB 버퍼 풀
3. InnoDB 어댑티브 해시 인덱스
4. InnoDB 리두 로그 버퍼



#### 로컬 메모리 영역

세션 메모리 영역이라고도 표현하며, MySQL 서버상에 존재하는 클라이언트 쓰레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.

대표적인 로컬 메모리 영역은 다음과 같다.

1. 정렬 버퍼
2. 커넥션 버퍼
3. 조인 버퍼
4. 바이너리 로그 캐시
5. 네트워크 버퍼

다음 클라이언트 요청 처리 워크플로우를 한번 보자.

```
클라이언트 요청 -> MySQL 접속 -> MySQL은 요청을 처리하기 위해 쓰레드 1개 할당 -> 작업 처리 -> 쓰레드 후처리 작업 진행
```

위 과정에서 클라이언트 쓰레드가 요청을 처리하기 위해서 메모리를 사용하는데 이를 **클라이언트 메모리 영역**이라고도 한다. 혹은 클라이언트와 MySQL의 커넥션을 세션이라 부르기 때문에 로컬 메모리 영역을 **세션 메모리 영역** 이라고도 표현한다.

로컬 메모리 영역은 다음과 같은 특징을 가지고 있다.

1. 각 클라이언트 쓰레드 별로 독립적으로 할당되며 절대 공유되지 않음
2. 글로벌 메모리 설정 보다 중요하지 않지만 가끔 최악으로 메모리 부족으로 멈출 수 있기 때문에 적절한 메모리 공간 설정이 필요
3. 각 쿼리의 용도별로 필요할 때만 공간이 할당되고, 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수 있음
   * 대표적으로 소트 버퍼나 조인 버퍼가 그러함
4. 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 로컬 메모리 공간을 지님 ( 커넥션 버퍼나 결과 버퍼 )
5. 쿼리를 실행하는 순간에만 할당했다가 해제하는 로컬 메모리 공간을 지님 ( 소트 버퍼나 조인 버퍼 )
