# 블록 네스티드 루프 조인

앞에 말했던 네스티드 루프 조인은 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.

다음 예를 보자

```mysql
> EXPLAIN
  SELECT *
  FROM employees e
    INNER JOIN salaries s ON s.emp_no=e.emp_no // 네스티드 루프 조인
      AND s.from_data <= NOW()
      AND s.to_date >= NOW()
  WHERE e.frist_name = 'Amor';
  
-----------------------------------------------------------------------
| id | select_type | table | type | key          | rows | Extra       |
-----------------------------------------------------------------------
| 1  | SIMPLE     | e      | ref  | ix_firstname | 1    | NULL        |     
| 1  | SIMPLE     | s      | ref  | PRIMARY      | 10   | Using where |
-----------------------------------------------------------------------
```

위 조인에서 네스티드 루프 조인을 사용함으로써 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아서 반환한다는 것을 알 수 있다.

네스티드와 블록 네스티드의 차이점은 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐다.

조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다. 즉 드라이빙 테이블은 한번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽은다는 것을 의미하는데, 예를 들어 드라이빙 테이블에서 1000건의 일치하는 레코드가 있다면, 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해, 1000번의 풀 테이블 스캔을 해야 한다. 

이렇게 엄청나게 느려질 수 있기 때문에, 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.

하지만 어떤 방식으로도 드리븐 풀테이블 스캔과 인덱스 풀 스캔을 피할 수 없다면, 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이때 사용되는 메모리의 캐시를 조인 버퍼라고 한다. join_buffer_size라는 시스템 변수로 크기를 제한할 수 있으며, 조인이 완료되면 조인 버퍼는 바로 해제된다.

다음 예를 보자

```mysql
> SELECT *
  FROM dept_emp de, employees e
  WHERE de.from_date > '1995-01-01' AND e.emp_no < 109004;
```

위 예에서 실행계획은 다음과 같다.

```mysql
----------------------------------------------------------------------------------------------------
| id | select_type | table  | type   | key          | rows | Extra                                 |
----------------------------------------------------------------------------------------------------
| 1  | SIMPLE     | de      | range  | ix_fromdate  | 1    | Using index condition                 |     
| 1  | SIMPLE     | e       | range  | PRIMARY      | 10   | Using join buffer (block nested loop) |
----------------------------------------------------------------------------------------------------
```

이를 풀이하면 다음과 같다.

1. dept_emp 테이블의 ix_fromdate 인덱스를 이용해 (from_date > '1995-01-01') 조건을 만족하는 레코드를 검색한다.
2. 조인에 필요한 나머지 컬럼을 모두 dept_emp 테이블로부터 읽어서 조인 버퍼에 저장한다.
3. employees 테이블의 프라이머리 키를 이용해 emp_no<109004 조건을 만족하는 레코드를 검색한다.
4. 3번에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합해서 반환한다.

이 방식에 가장 큰 특징은 조인이 거꾸로 실행되는 것처럼 보인다. 그 이유는 드라이빙 테이블의 결과를 버퍼에 담아두고 드리븐 테이블을 먼저 읽고 버퍼에 일치하는 레코드를 찾는 방식으로 사용하기 때문이다. 