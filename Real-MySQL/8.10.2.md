# 부모 테이블의 변경 작업이 대기하는 경우

| 작업 번호 | 커넥션 - 1                                                   | 커넥션 - 2                                                   |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1         | BEGIN;                                                       |                                                              |
| 2         | UPDATE tb_child<br />SET fd='changed-100' WHERE id = 100; // 쓰기 잠금 획득 |                                                              |
| 3         |                                                              | BEGIN;                                                       |
| 4         |                                                              | DELETE FROM tb_parent<br />WHERE id = 1; // 기다림           |
| 5         | ROLLBACK; // 끝                                              |                                                              |
| 6         | // 같이 사라짐                                               | Query OK; // 커넥션 1에서 자식이 부모 테이블의 쓰기 잠금을 획득했기 때문에 쓰기잠금이 해제된 후 바로 삭제 쿼리가 실행 |

위 예제에서 다음과 같이 동작한 이유는 자식 테이블이 생성될 때 정의된 외래키의 특성 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문이다. (DELETE CASCADE)

따라서 외래키를 물리적으로 생성하려면 이러한 잠금 경합 현상까지 고려해 모델링을 진행하는 것이 좋다. 그리고 이렇게 잠금이 다른 테이블로 확장되면 전체적으로 쿼리의 동시 처리에 영향을 미치기 때문에 신중하게 설계를 해야 한다.