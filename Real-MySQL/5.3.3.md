# 레코드수준의 잠금 확인 및 해제

InnoDB 스토리 엔진이 사용하는 ***테이블 레코드 수준의 잠금은***  테이블 수준의 잠금보다는 조금 더 복잡하다. 테이블 잠금은 잠금의 대상이 테이블 자체라 파악하기 쉽지만 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸려있어 파악하기 쉽지 않다.

잠금을 해제하려면 KILL 명령어를 사용하면 된다. 다음을 한번 보자.

| 커넥션1                                                      | 커넥션2                                                      | 커넥션3                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| BEGIN;                                                       |                                                              |                                                              |
| UPDATE employees <br />SET birth_date=NOW() WHERE<br />emp_no = 100001; |                                                              |                                                              |
|                                                              | UPDATE employees <br />SET hire_date=NOW() <br />WHERE emp_no = 100001; |                                                              |
|                                                              |                                                              | UPDATE employees <br />SET hire_date=NOW(), birth_date=NOW() <br />WHERE emp_no = 100001; |

각 트랜잭션이 어떤 잠금을 기다리고 있는지, 기다리고 있는 잠금을 어떤 트랜잭션이 가지고 있는지를 쉽게 메타 정보를 통해 조회할 수 있다.

5.1부터는 information_schema를 통해 메타 정보를 조회할 수 있지만 버전이 올라갈수록 deprecated 되고 8.0부터 performance_schema로 대체 되어지고 있다.

그럼 perfomance_schema를 통해 위 예제의 잠금 대기 순서를 한번 보자.

* UPDATE 명령 3개가 실행된 상태의 프로세스 목록 조회

```mysql
> SHOW PROCESSLIST;

| Id | Time |   State  |         Info       |
---------------------------------------------
| 17 | 607  |          |         NULL       |
| 18 | 22   | updating | UPDATE employee....|
| 19 | 21   | updating | UPDATE employee....|
```

위 예제를 보면 17번 쓰레드는 지금 아무것도 하지 않지만 트랜잭션을 시작하고 UPDATE 명령이 실행 완료된 것이다. 

하지만 17번 쓰레드는 Commit을 실행하지 않은 상태이므로 업데이트한 레코드의 잠금은 그대로 가지고 있는 상태이다. 다음으로 18번이 UPDATE 명령어를 실행했으며, 그 이후 19번이 실행했다.

따라서 18, 19번 쓰레드는 17번의 잠금 대기로 인해 아직 UPDATE 명령을 실행 중인 것으로 표시된 것이다. 

그렇다면 다음 예제를 보자.

* data_locks 테이블과 data_lock_waits 테이블의 조인 결과

| waiting_trx_id | waiting_thread | waiting_query        | blocking_trx_id | blocking_thread | blocking_query      |
| -------------- | -------------- | -------------------- | --------------- | --------------- | ------------------- |
| 11990          | 19             | UPDATE employees ... | 11989           | 18              | UPDATE employees... |
| 11990          | 19             | UPDATE employees ... | 11984           | 17              | NULL                |
| 11989          | 18             | UPDATE employees ... | 11984           | 17              | NULL                |

위 예제를 보면 18번과 19번이 현재 대기 쓰레드인 것을 볼 수 있다. 18번 쓰레드는 17번 쓰레드를 기다리고 있고, 19번 쓰레드는 17번, 18번 쓰레드를 기다리고 있다는 것을 알 수 있다.

이는 잠금 대기 큐의 내용을 그대로 보여주기 때문에 이렇게 표시되는 것이다. 즉 17번 쓰레드가 가지고 있는 잠금을 해제하고, 18번 쓰레드가 그 잠금을 획득하고 UPDATE를 완료한 후 잠금을 풀어야만 비로소 19번 쓰레드가 UPDATE를 실행할 수 있음을 의미한다. 

더 상세히 확인하고 싶다면 performance_schema의 data_locks 테이블이 가진 컬럼을 모두 살펴보면 된다.

그리고 만약 17번의 쓰레드가 잠금을 오래가지고 있으면 `KILL 17;` 명령어를 통해 강제 종료시켜 잠금 경합이 끝낼 수 있다.